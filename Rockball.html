<!DOCTYPE html>
<html>
<head>
    <style>
        body { margin: 0; overflow: hidden; background: transparent; }
        canvas { display: block; background: transparent; }
    </style>
</head>
<body>
<script>
const canvas = document.createElement('canvas');
document.body.appendChild(canvas);
const ctx = canvas.getContext('2d');

class Ball {
    constructor(radius) {
        this.radius = radius;
        this.x = Math.random() * (canvas.width - 2 * radius) + radius;
        this.y = Math.random() * (canvas.height - 2 * radius) + radius;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        // 边界碰撞
        if (this.x < this.radius) {
            this.x = this.radius;
            this.vx *= -1;
        } else if (this.x > canvas.width - this.radius) {
            this.x = canvas.width - this.radius;
            this.vx *= -1;
        }
        if (this.y < this.radius) {
            this.y = this.radius;
            this.vy *= -1;
        } else if (this.y > canvas.height - this.radius) {
            this.y = canvas.height - this.radius;
            this.vy *= -1;
        }
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
}

const balls = [];

function initBalls() {
    while (balls.length < 5) {
        const radius = Math.random() * 20 + 10;
        const newBall = new Ball(radius);
        let valid = true;
        
        // 检查重叠
        for (const ball of balls) {
            const dx = ball.x - newBall.x;
            const dy = ball.y - newBall.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < ball.radius + newBall.radius) {
                valid = false;
                break;
            }
        }
        if (valid) balls.push(newBall);
    }
}

function handleCollisions() {
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i];
            const b2 = balls[j];
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < b1.radius + b2.radius) {
                // 位置修正
                const overlap = (b1.radius + b2.radius - dist) / 2;
                const nx = dx / dist;
                const ny = dy / dist;
                const massSum = b1.radius + b2.radius;
                
                b1.x -= nx * overlap * (b2.radius / massSum);
                b1.y -= ny * overlap * (b2.radius / massSum);
                b2.x += nx * overlap * (b1.radius / massSum);
                b2.y += ny * overlap * (b1.radius / massSum);

                // 速度交换
                const tx = -ny;
                const ty = nx;
                const v1n = nx * b1.vx + ny * b1.vy;
                const v1t = tx * b1.vx + ty * b1.vy;
                const v2n = nx * b2.vx + ny * b2.vy;
                const v2t = tx * b2.vx + ty * b2.vy;

                const m1 = b1.radius;
                const m2 = b2.radius;
                const newV1n = (v1n * (m1 - m2) + 2 * m2 * v2n) / (m1 + m2);
                const newV2n = (v2n * (m2 - m1) + 2 * m1 * v1n) / (m1 + m2);

                b1.vx = nx * newV1n + tx * v1t;
                b1.vy = ny * newV1n + ty * v1t;
                b2.vx = nx * newV2n + tx * v2t;
                b2.vy = ny * newV2n + ty * v2t;
            }
        }
    }
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    initBalls();
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    handleCollisions();
    balls.forEach(ball => {
        ball.update();
        ball.draw();
    });
    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
